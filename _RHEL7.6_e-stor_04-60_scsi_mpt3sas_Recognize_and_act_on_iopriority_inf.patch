Date: Fri,  1 Jun 2018 16:59:40 +0200
From: Tomas Henzl <thenzl@redhat.com>
To: rhkernel-list@redhat.com
Subject: [RHEL7.6 e-stor 04/60] scsi: mpt3sas: Recognize and act on
 iopriority info

This patch adds support for request iopriority handling in the mpt3sas
layer. This works only when a ATA device is behind the SATL. The ATA
device also has to indicate that it supports command priorities in the
identify information that is pulled from the SATL.

Signed-off-by: Adam Manzanares <adam.manzanares@wdc.com>
Acked-by: Sreekanth Reddy <Sreekanth.Reddy@broadcom.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 307d9075a02b696e817b775c565e45c4fa3c32f2)

Conflicts:
	drivers/scsi/mpt3sas/mpt3sas_base.h
	drivers/scsi/mpt3sas/mpt3sas_scsih.c
(in scsih_qcmd and struct MPT3SAS_DEVICE)
---
 drivers/scsi/mpt3sas/mpt3sas_base.h  |  5 +++++
 drivers/scsi/mpt3sas/mpt3sas_ctl.c   | 43 ++++++++++++++++++++++++++++++++++--
 drivers/scsi/mpt3sas/mpt3sas_scsih.c | 33 +++++++++++++++++++++++++++
 3 files changed, 79 insertions(+), 2 deletions(-)

Index: src/drivers/scsi/mpt3sas/mpt3sas_base.h
===================================================================
--- src.orig/drivers/scsi/mpt3sas/mpt3sas_base.h	2018-09-07 06:11:42.474661582 +0200
+++ src/drivers/scsi/mpt3sas/mpt3sas_base.h	2018-09-07 06:23:53.202818067 +0200
@@ -419,6 +419,8 @@
 	 * thing while a SATL command is pending.
 	 */
 	unsigned long ata_command_pending;
+	/* Iopriority Command Handling */
+	u8	ncq_prio_enable;
 
 };
 
@@ -1573,4 +1575,7 @@
 	struct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,
 	u16 smid);
 
+/* NCQ Prio Handling Check */
+bool scsih_ncq_prio_supp(struct scsi_device *sdev);
+
 #endif /* MPT3SAS_BASE_H_INCLUDED */
Index: src/drivers/scsi/mpt3sas/mpt3sas_ctl.c
===================================================================
--- src.orig/drivers/scsi/mpt3sas/mpt3sas_ctl.c	2018-09-05 17:29:34.182174038 +0200
+++ src/drivers/scsi/mpt3sas/mpt3sas_ctl.c	2018-09-07 06:23:53.202818067 +0200
@@ -3321,8 +3321,6 @@
 
 /*********** diagnostic trigger suppport *** END ****************************/
 
-
-
 /*****************************************/
 
 struct device_attribute *mpt3sas_host_attrs[] = {
@@ -3398,9 +3396,50 @@
 }
 static DEVICE_ATTR(sas_device_handle, S_IRUGO, _ctl_device_handle_show, NULL);
 
+/**
+ * _ctl_device_ncq_io_prio_show - send prioritized io commands to device
+ * @dev - pointer to embedded device
+ * @buf - the buffer returned
+ *
+ * A sysfs 'read/write' sdev attribute, only works with SATA
+ */
+static ssize_t
+_ctl_device_ncq_prio_enable_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+	struct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			sas_device_priv_data->ncq_prio_enable);
+}
+
+static ssize_t
+_ctl_device_ncq_prio_enable_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+	struct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;
+	bool ncq_prio_enable = 0;
+
+	if (kstrtobool(buf, &ncq_prio_enable))
+		return -EINVAL;
+
+	if (!scsih_ncq_prio_supp(sdev))
+		return -EINVAL;
+
+	sas_device_priv_data->ncq_prio_enable = ncq_prio_enable;
+	return strlen(buf);
+}
+static DEVICE_ATTR(sas_ncq_prio_enable, S_IRUGO | S_IWUSR,
+		   _ctl_device_ncq_prio_enable_show,
+		   _ctl_device_ncq_prio_enable_store);
+
 struct device_attribute *mpt3sas_dev_attrs[] = {
 	&dev_attr_sas_address,
 	&dev_attr_sas_device_handle,
+	&dev_attr_sas_ncq_prio_enable,
 	NULL,
 };
 
Index: src/drivers/scsi/mpt3sas/mpt3sas_scsih.c
===================================================================
--- src.orig/drivers/scsi/mpt3sas/mpt3sas_scsih.c	2018-09-07 06:11:42.477661542 +0200
+++ src/drivers/scsi/mpt3sas/mpt3sas_scsih.c	2018-09-07 06:23:53.202818067 +0200
@@ -4398,6 +4398,8 @@
 	struct MPT3SAS_DEVICE *sas_device_priv_data;
 	struct MPT3SAS_TARGET *sas_target_priv_data;
 	struct _raid_device *raid_device;
+	struct request *rq = scmd->request;
+	int class;
 	Mpi2SCSIIORequest_t *mpi_request;
 	u32 mpi_control;
 	u16 smid;
@@ -4476,6 +4478,12 @@
 	} else
 		mpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;
 
+	/* NCQ Prio supported, make sure control indicated high priority */
+	if (sas_device_priv_data->ncq_prio_enable) {
+		class = IOPRIO_PRIO_CLASS(req_get_ioprio(rq));
+		if (class == IOPRIO_CLASS_RT)
+			mpi_control |= 1 << MPI2_SCSIIO_CONTROL_CMDPRI_SHIFT;
+	}
 	/* Make sure Device is not raid volume.
 	 * We do not expose raid functionality to upper layer for warpdrive.
 	 */
@@ -9648,6 +9656,31 @@
 	return PCI_ERS_RESULT_RECOVERED;
 }
 
+/**
+ * scsih__ncq_prio_supp - Check for NCQ command priority support
+ * @sdev: scsi device struct
+ *
+ * This is called when a user indicates they would like to enable
+ * ncq command priorities. This works only on SATA devices.
+ */
+bool scsih_ncq_prio_supp(struct scsi_device *sdev)
+{
+	unsigned char *buf;
+	bool ncq_prio_supp = false;
+
+	if (!scsi_device_supports_vpd(sdev))
+		return ncq_prio_supp;
+
+	buf = kmalloc(SCSI_VPD_PG_LEN, GFP_KERNEL);
+	if (!buf)
+		return ncq_prio_supp;
+
+	if (!scsi_get_vpd_page(sdev, 0x89, buf, SCSI_VPD_PG_LEN))
+		ncq_prio_supp = (buf[213] >> 4) & 1;
+
+	kfree(buf);
+	return ncq_prio_supp;
+}
 /*
  * The pci device ids are defined in mpi/mpi2_cnfg.h.
  */
